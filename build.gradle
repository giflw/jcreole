defaultTasks 'jar'

/**
 * You can add to what is here by creating a build file name "local.gradle".
 * If present, it will be applied automatically.
 * One use case for this is to define additional repositories.
 */

project['repos.useMaven'] = 'true'
apply from: 'common.gradle'
apply plugin: 'java'
apply plugin: 'maven'

// This only present because a Java boolean can't be set in a Java properties
// file.
compileJava.options.debug = (!project.hasProperty('javac.debug')
            || Boolean.parseBoolean(project.property('javac.debug')))
sourceCompatibility = '1.5'
targetCompatibility = sourceCompatibility
description = 'JCreole Creole'

//  Work-around for Gradle bug where Runtime classpath must include every
//  Compilation classpath element:
configurations {
    compileOnly
    jflex
    beaver
    baseconf
    run
}

// De-transify dependencies. We aim for precision, not laziness.
//for (Configuration c in configurations) c.transitive = false
// We now let 'ivy.xml' configure transitiveness.

project.rtLibs = null
jar { doFirst {
    project.rtLibs = []
    configurations.runtime.files.each { project.rtLibs << it.name }
    String implVendor = (project.hasProperty('organization')
                        ? project.organization
                        : System.properties['user.name'])
    project.metaInf << files('doc/LICENSE.txt')
    jar { manifest { attributes(
        'Main-Class': 'com.admc.jcreole.JCreole',
        'Class-Path': project.rtLibs.join(' '),
        'Specification-Title': 'JCreole',
        'Specification-Version': project.version,
        'Specification-Vendor': 'Axis Data Management Corp.',
        'Implementation-Title': 'JCreole executable jar',
        'Implementation-Version': project.version,
        'Implementation-Vendor': implVendor
    ) } }
} }

task beaver << {
    File grammarFile = file('src/com/admc/jcreole/CreoleParser.grammar')
    File parserFile =
            file('build/derived-src/com/admc/jcreole/CreoleParser.java')
    if (parserFile.exists()) parserFile.delete()
    javaexec {
        main = '-jar'
        args = [configurations.beaver.asPath, '-d', 'build/derived-src',
                '-t', '-T', grammarFile.path]
    }
    assert parserFile.exists()
}
beaver.description = '''Generate Beaver parser 'CreoleParser'.'''
beaver.onlyIf {
    File grammarFile = file('src/com/admc/jcreole/CreoleParser.grammar')
    File scannerFile =
            file('build/derived-src/com/admc/jcreole/CreoleParser.java')
    (!grammarFile.exists()
            || grammarFile.lastModified() > scannerFile.lastModified())
}

task jflex (dependsOn: beaver) << {
    /*
task jflex (dependsOn: beaver) {
    inputs.source fileTree(
        dir:'src', exclude:'**&.*&**', include:'com/admc/jcreole&*.grammar')
    inputs.file new File('src/com/admc/jcreole/CreoleParser.grammar')
    outputs.file new File('build/derived-src/com/admc/jcreole/CreoleScanner.java')
    doLast {
    */
        File flexFile = file('src/com/admc/jcreole/creole.flex')
        String jxVerbSwitch = ((project.hasProperty('jflex.verbose')
            && Boolean.parseBoolean(project.property('jflex.verbose')))
            ? '-v' : '-q')
        javaexec {
            main = '-jar'
            args = [configurations.jflex.asPath, '-d',
                    // JFlex is so brain-dead that unlike their own Ant task,
                    // their base product won't move output files into
                    // appropriate package subdirectories, so we must specify.
                    'build/derived-src/com/admc/jcreole', jxVerbSwitch,
                    '--nobak', flexFile.path]
        }
    /*
    }
    <mkdir dir="build/derived-src"/>
    <jflex file="src/com/admc/jcreole/creole.flex" destdir="build/derived-src"
           verbose="${jflex.debug}" nobak="true" />
       */
}
jflex.description = '''Generate JFlext scanner 'CreoleScanner'.'''
jflex.onlyIf {
    File flexFile = file('src/com/admc/jcreole/creole.flex')
    File termsFile = file('build/derived-src/com/admc/jcreole/Terminals.java')
    File scannerFile =
            file('build/derived-src/com/admc/jcreole/CreoleScanner.java')
    if (!termsFile.exists()) {
        // Can't just use 'assert' here, or even throw an Exception,
        // because Gradle hides output generated by onlyIf calls.
        logger.error(
                'dependOn failed to generate Terminals.java before JFlex runs')
        assert false:
                'dependOn failed to generate Terminals.java before JFlex runs'
    }
    (!scannerFile.exists()
            || flexFile.lastModified() > scannerFile.lastModified()
            || termsFile.lastModified() > scannerFile.lastModified())
}

// This task only for SCM administrator.  Update version and execute this task.
task updateWrapper(type: Wrapper) { doFirst {
    assert project.hasProperty('newVersion') :
            "Property 'newVersion' is required for task 'updateWrapper'"
    assert project.newVersion == gradle.gradleVersion :
        "You invoke Gradle system with version $gradle.gradleVersion instead of desired version $project.newVersion"
} }
updateWrapper << {
    gradleVersion = project['newVersion']
    println 'WARNING:  Merge our customizations into the newly-generated wrapper scripts'
}
updateWrapper.description = 'Update Gradle version.  For HSQLDB Administrators.'

task serialver(dependsOn: compileJava) << {
    assert project.hasProperty('className'):
            '''Property 'className' is required for task 'serialver'.'''
    String fileSep = System.properties['file.separator']
    // Could alternatively use Gradle's ExecSpec via exec(...)
    String javaHome = System.properties['java.home']
    String javacHome = (javaHome.endsWith("jre")
            ? javaHome.substring(0, javaHome.length() - "/jre".length())
            : javaHome)
    Process process = new ProcessBuilder([
        javacHome + fileSep + 'bin' + fileSep + 'serialver',
        '-classpath',
        'classes' + System.properties['path.separator']
                + configurations.runtime.asPath,
        project.property('className')
    ]).redirectErrorStream(true).start()
    // Must read input before waitFor-ing
    File outFile = new File(System.properties['java.io.tmpdir'],
                'serialVer-' + System.properties['user.name'] + '.txt')
    process.inputStream.eachLine { println it; outFile.write(it + '\n') }
    assert process.waitFor() == 0:  '''Execution of 'serialver' failed'''
    println """Also written to file '$outFile.absolutePath'
so you can read it into your editor."""
}
serialver.description = "Generates Java serialversion for specified 'classname'"

void resolveCheck(configName) {
    int artCount = configurations[configName].files.size()
    // Following test works only if deps' transitive is false.
    if (configurations[configName].allDependencies.size() != artCount) {
        logger.error(
                "Didn't resolve all dependencies for config '$configName'.  "
                + configurations[configName].allDependencies.size()
                + ' dependencies:\n    ' + configurations[configName]
                .allDependencies .collect({it.name}).join('\n    ')
                + '\nbut ' + artCount
                + ' resolved artifacts:\n    '
                + configurations[configName].files.collect({it}).join('\n    ')
                + '\n'
        )
        assert false : "Didn't resolve all dependencies."
    }
    //configurations[configName].files.each { println '+' + it }
    //throw new GradleException("Quittin' early")
    logger.info "$artCount  artifacts resolved"
}

compileJava.dependsOn jflex

sourceSets.test.java.srcDirs = [file('test-src')]
sourceSets.main.java.srcDirs = [file('src'), file('build/derived-src')]
sourceSets.main.resources.srcDirs = [file('resources')]
//sourceSets.main.java.srcDirs << file('src')
//java.srcDirs << file('build/derived-src')
compileJava.dependsOn << {
    if (!project.hasProperty('resolveCheck.skip')
            || !Boolean.parseBoolean(project.property('resolveCheck.skip')))
        resolveCheck('compile')
}

task checkTabs << {
    FileTree tree = fileTree(dir: '.')
    tree.exclude '**/.*/**'
    tree.include  '*.*'
    tree.include  'gradlew'
    tree.include  'src/**'
    tree.include  'doc/**'
    def tabFiles = []
    tree.each { if (it.text.indexOf('\t') > -1) tabFiles << relativePath(it) }
    if (tabFiles.size() > 0) println '  ' + tabFiles.join('\n  ')
}
checkTabs.description = 'Reports on any text files containing tab characters'

/*
          depends="ref, condl-javadoc">
         filesonly="true" whenempty="fail">
                  dir="tmp/stage" excludes="**@.*"/>
                  dir="." excludes="**@.*" includes="doc@**"/>
                  dir="dist" excludes="**@.*" includes="apidocs@**"/>
      <zipfileset prefix="${ant.project.name}-${version}/doc"
                  file="README.txt"/>
      <zipfileset prefix="${ant.project.name}-${version}/doc"
                  dir="tmp" includes="jcreole-ref.html"/>
task zip(dependsOn: 'jar, javadoc', type: Zip) {
    from configurations.runtime.allArtifacts.files
    from configurations.runtime
    from new File(buildDir, 'filtered-docs')
    into(project.name + '-' + project.version)
}
zip.description =
        'Build zip of end-user executable JCreole jar with dependencies'

import java.text.SimpleDateFormat
import org.apache.tools.ant.filters.ReplaceTokens
import org.apache.tools.ant.filters.FixCrLfFilter
zip { doFirst {
    copy {
        from 'doc'
        into new File(buildDir, 'filtered-docs')
        exclude '**@.*@**'
        filter(ReplaceTokens, tokens: [
            VERSION: (upstreamVersion
                    + ' (ADMC Relames v. ' + project.version + ')'),
            YEAR: new SimpleDateFormat("yyyy").format(new Date())
        ])
        //Ask how to do this at Gradle forum:
        //filter(FixCrLfFilter, eol: 'lf')
    }
} }
*/

task stage(dependsOn: jar, type: Copy) {
    from configurations.runtime.allArtifacts.files
    from configurations.runtime
    into 'build/stage'
}
stage.description = 'Stage JCreole jar and dependency jars in build/stage'
//task x << { println configurations.runtime.allArtifacts.files.asPath }

task ensureLogCfgfile << {
    assert !project.julCfgfile.exists():
        """ensureLogCfgfile's onlyIf not working because running even though
target file exists:  $project.julCfgfile.absolutePath"""
    project.julCfgfile.write(
            file('template-jul.properties').getText('ISO-8859-1'), 'ISO-8859-1')
    println """Local logging cfg file created.  Edit per your needs:
$julCfgfile"""
}
ensureLogCfgfile.onlyIf {
    project.julCfgfile = new File(project.hasProperty('jul.cfgfile')
            ? project.property('jul.cfgfile') : 'local-jul.properties')
    !project.julCfgfile.exists()
}

task ref(dependsOn: ['stage', 'ensureLogCfgfile']) << {
    String refStyle = (project.hasProperty('refStyle')
            ? project.property('refStyle') : 'default')
    /*   Set ant param 'refstyle' to 'jqueryui' to generate jquery-ui dependent
         document, instead of the default standalone document. */
    javaexec {
        main = '-jar'
        args = [ 'build/stage/' + project.name + '-' + project.version
                + '.jar',
                '-r',
                'boilerplate-' + refStyle + '.html',
                '-o', 
                'tmp/jcreole-ref.html',
                'jcreole-ref.creole'
        ]
        systemProperties 'java.util.logging.config.file': julCfgfile.path
    }
    println '''HTML reference written to 'tmp/jcreole-ref.html'.'''
}
ref.description = 'Generate JCreole Reference doc'

apply from: 'ivyxml-support.gradle'

// Following 3 tasks copied from
// http://blog.andresteingress.com/2011/01/14/using-gradle-in-practice/
// custom tasks for creating source/javadoc jars
task sourcesJar(type: Jar, dependsOn:classes) {
     classifier = 'sources'
     from sourceSets.main.allSource
}
sourcesJar.description = 'Build sources jar file'

// Required for Gradle 1.0 milestone 3, but not for milestone 5:
javadoc.failOnError = false
 
task javadocJar(type: Jar, dependsOn:javadoc) {
     classifier = 'javadoc'
     from javadoc.destinationDir
}
sourcesJar.description = 'Build javadoc jar file'
 
// add javadoc/source jar tasks as artifacts
artifacts {
     archives sourcesJar
     archives javadocJar
}

//apply from: 'build-dist.gradle'
