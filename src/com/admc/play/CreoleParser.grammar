%package "com.admc.play";

%import "java.util.List";

%embed {:
    private boolean validateOnly;
    private StringBuilder sb = new StringBuilder();
    public void setValidateOnly(boolean validateOnly) {
        this.validateOnly = validateOnly;
    }
    public void out(String s) {
        if (validateOnly) return;
        sb.append(s);
        sb.append('\n');
    }
    /*  I believe our scanner will always provide Strings, so we'll never need
     *  to write individual chars.
    public void out(char c) {
        if (validateOnly) return;
        sb.append(c);
        sb.append('\n');
    }
    */
    public String getOutput() {
        return sb.toString();
    }

    public static String xmlEscape(String s) {
        return s.replace("<", "&lt;").replace(">", "&gt;");
        // TODO:  Obviously complete the mappings.
    }

    /**
     * Returns a single XML-washed String
     */
    public static StringBuilder concat(List inList) {
        @SuppressWarnings("unchecked")
        List<Symbol> symList = (List<Symbol>) inList;
        Token t;
        StringBuilder sb = new StringBuilder();
        for (Symbol s : symList) {
            if (!(s instanceof Token))
                throw new IllegalStateException(
                        "frag element not a Token but a "
                        + s.getClass().getName());
            t = (Token) s;
            if (!(t instanceof WashedToken) && !(t.value instanceof String))
                throw new IllegalStateException(
                        "frag element value not a String but a "
                        + t.value.getClass().getName());
            sb.append((t instanceof WashedToken)
                    ? ((WashedToken) t).getCleanString()
                    : xmlEscape(t.getStringVal()));
        }
        return sb;
    }
:};

%terminals BLOCK_PRE, INLINE_PRE, TEXT, HARDSPACE, END_PARA;

%typeof BLOCK_PRE, INLINE_PRE, TEXT = "String";

%goal blocks;

/* The grammar */
blocks = block.b+ {:
            return new WashedToken(concat(_list_b).toString());
        :}
        |;  // This last allows for empty document
block = BLOCK_PRE.text {:
            return new WashedToken(
                    "<pre>\n" + xmlEscape(text) + "\n</pre>\n");
        :}
        | frag.f+ END_PARA {:
            if (((Symbol) _list_f.get(f.length-1)).value.equals("\n"))
                _list_f.remove(f.length-1);
            return new WashedToken("<p>\n" + concat(_list_f) + "\n</p>\n");
        :};
frag = INLINE_PRE.text {: return new WashedToken("<span class=\"pref\">"
                    + xmlEscape(text) + "</span>");
        :}
        | TEXT
        | HARDSPACE {: return new WashedToken("&nbsp;"); :};
