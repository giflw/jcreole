/*
 * Copyright 2011 Axis Data Management Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


%package "com.admc.jcreole";

%import "java.net.URL";
%import "java.net.MalformedURLException";
%import "java.util.regex.Pattern";
%import "java.util.Set";
%import "java.util.EnumSet";
%import "java.util.HashSet";
%import "java.util.List";
%import "java.util.Map";
%import "java.util.HashMap";
%import "java.util.regex.Matcher";
%import "java.util.Deque";
%import "java.util.ArrayDeque";
%import "java.util.Collections";
%import "org.apache.commons.logging.Log";
%import "org.apache.commons.logging.LogFactory";
%import "org.apache.commons.lang.StringEscapeUtils";
%import "org.apache.commons.lang.StringUtils";
%import "org.apache.commons.lang.WordUtils";
%import "com.admc.jcreole.marker.*";

%embed {:
    private static Log log = LogFactory.getLog(CreoleParser.class);

    // TODO:  urlBase and pathBase need to be instance vars set by setter or
    //        constructor param.
    // TODO:  Think about whether this generous whitespace stripping is ok.
    private static Pattern ImgAsLabelPattern =
            Pattern.compile("\\s*\\Q{{\\E\\s*(.+?)\\s*\\Q}}\\E\\s*");
    private static Pattern InterWikiPattern =
            Pattern.compile("([^:]+)?:([^?#]+)(.+)?");
    private static Pattern StylerPattern = Pattern.compile(
            "([-+=])(block|inline|jcxSpan|jcxBlock)\\s+(.*[-\\w])");
    public static final Pattern CssNamesPattern =
            Pattern.compile("[a-zA-Z_][-\\w]*(?:\\s+[a-zA-Z_][-\\w]*)*");
    public static final Pattern EnumFormatPattern =
            Pattern.compile("[_xaA01]{6}");
    public static final Pattern SlashDelimitedPattern =
            Pattern.compile("([^/]+)?(?:/\\s*(\\S+))?");
    private static final Symbol DUMMY_SYMBOL = new Symbol(null);
    private static final WashedSymbol DUMMY_WASHEDSYMBOL
            = new WashedSymbol(null);
    /**
     * Defaults to displaying no section enumeration labels (in body headings
     * or in TOCs) and skips heading levels 5 and 6 in TOCs.
     */
    public static final String DEFAULT_ENUMERATION_FORMATS = "____xx";
    public static final EnumSet<PluginPrivilege> DEFAULT_PLUGIN_PRIVILEGES =
        EnumSet.noneOf(PluginPrivilege.class);

    private boolean wrote;  // Just used to write block-separating blank lines
    private String urlBase;
    private String pathBase;
    private boolean authorSetEnumFormats;
    private InterWikiMapper interWikiMapper;
    private int lastMarkerId = 0;
    private MarkerMap markers = new MarkerMap();
    private List<String> cssHrefs = new ArrayList<String>();
    // hIds is only for checking ID uniqueness
    private Set<String> hIds = new HashSet<String>();
    private String sectIdPrefix = "jcsect_";
    private String enumerationFormats = DEFAULT_ENUMERATION_FORMATS;
    private Character formatResetChar;
    private EnumSet<PluginPrivilege> pluginPrivs = DEFAULT_PLUGIN_PRIVILEGES;

    /**
     * Set enumeration formats to display section/heading enumerations in TOCs
     * (if any) and in headings.
     * <p>
     * By default, no section/header enumerations are shown.
     * Creole authors can alternatively use the &lt;&lt;enumFormats&gt;&gt;
     * plugin directive to accomplish the same thing (assuming that they have
     * adequate privileges to do so).
     * </p>
     */
    public void setEnumerationFormats(String enumerationFormats) {
        if (enumerationFormats == null)
            throw new NullPointerException(
                    "enumerationFormats may not be null");
        if (!EnumFormatPattern.matcher(enumerationFormats).matches())
            throw new IllegalArgumentException(
                    "Malformatted enumerationFormats: " + enumerationFormats);
        this.enumerationFormats = enumerationFormats;
    }

    /**
     * Specify what plugin directives may be used by Creole page authors.
     */
    public void setPluginPrivileges(EnumSet<PluginPrivilege> pluginPrivs) {
        this.pluginPrivs = pluginPrivs;
    }

    /**
     * @see #setPluginPrivileges(EnumSet)
     */
    public EnumSet<PluginPrivilege> getPluginPrivileges() {
        return pluginPrivs;
    }

    public void setSectIdPrevix(String sectIdPrefix) {
        this.sectIdPrefix = sectIdPrefix;
    }

    public List<SectionHeading> getSectionHeadings() {
        return markers.getSectionHeadings();
    }

    /**
     * Strip out markers, HTML tags, and comments, but preserve text, entities,
     * punctuation that you would want to appear in labels.
     */
    private static String autoLabelText(String washedString) {
        return washedString
                .replaceAll("\\u001a\\w{4}", "").replaceAll("<+[^>]+?>+", "")
                //           - binary markers          - plugin HTML tags
                .trim().replaceAll("\\s+", " ");
        // Only HTML comments would still be present here, and the HTML tag
        // pattern covers them.
    }

    private String mkXmlId(String anyString) {
        String safeString = anyString.replaceAll("&\\w+;", "")
                .replaceAll("[^\\w\\s]", " ").replaceAll("\\s+", " ");
        // safeString is id-safe other than it may contain whitespace
        String s = sectIdPrefix + WordUtils.capitalizeFully(safeString)
                .replaceAll("\\s+", "");
        if (s.length() < 50 && !hIds.contains(s)) {
            hIds.add(s);
            return s;
        }
        s = sectIdPrefix + WordUtils.initials(safeString).toLowerCase();
        if (hIds.contains(s)) for (int i = 1; i < 10000; i++)
            if (!hIds.contains(s + i)) { s += i; break; }
        hIds.add(s);
        return s;
    }

    /**
     * Get list of CSS Hrefs that need to be loaded into the HTML page header.
     */
    public List<String> getCssHrefs() {
        return cssHrefs;
    }

    /**
     * Assign a mapper from wiki page names to actual paths or URLs to the
     * pages.
     *
     * @see InterWikiMapper
     */
    public void setInterWikiMapper(InterWikiMapper interWikiMapper) {
        this.interWikiMapper = interWikiMapper;
    }

    /**
     * Use this method and setPathBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setUrlBase(String urlBase) {
        this.urlBase = urlBase;
    }

    /**
     * Use this method and setUrlBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setPathBase(String pathBase) {
        this.pathBase = pathBase;
    }

    /**
     * Returns a single XML-washed String
     *
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     * The specified List must be all WashedSymbols.
     */
    public static StringBuilder joinWashedSymbols(List<WashedSymbol> wtList) {
        StringBuilder sb = new StringBuilder();
        for (WashedSymbol t : wtList) sb.append(t.toString());
        return sb;
    }

    /**
     * Returns a single XML-washed String
     *
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     * The specified List must be either all non-washed Tokens.
     */
    public static WashedSymbol mkWashedSymbol(List<String> sList) {
        //@SuppressWarnings("unchecked")
        StringBuilder sb = new StringBuilder();
        for (String s : sList) sb.append(s);
        return new WashedSymbol(clean(sb.toString()));
    }

    /** 
     * Applies urlBase and/or pathBase to relative URLs.
     * Has no effect if neither urlBase nor pathBase are set.
     */
    private String absoluteUrl(String path) {
        if (urlBase == null && pathBase == null) return path;
        if (path.length() > 0 && path.charAt(0) == '#') {
            return path;
        } else if (path.length() > 0 && path.charAt(0) == '/') {
            return urlBase + path;
        } else try {
            new URL(path);
        } catch (MalformedURLException mue) {
            return ((urlBase == null) ? "" : urlBase)
                    + ((pathBase == null) ? "" : pathBase) + '/' +  path;
        }
        return path;
    }

    private static boolean isAbsoluteUrl(String path) {
        if (path.length() > 0 && path.charAt(0) == '#') return false;
        if (path.length() > 0 && path.charAt(0) == '/') return false;
        try {
            new URL(path);
        } catch (MalformedURLException mue) {
            return false;
        }
        return true;
    }

    /**
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     *
     * Preserves &...; entities in input but otherwise applies new entities to
     * escape special HTML characters.
     */
    public static String clean(String s) {
        return StringEscapeUtils.escapeHtml(s.replaceAll("&(?=\\w+;)", "\b"))
                .replace('\b', '&');
    }

    private enum InlineMode {
        EMPHASIZED("em"),
        STRONG("strong"),
        JCXSPAN("span"),  // cssClass attr not used for this one
        MONO("tt"),
        SUP("sup"),
        SUB("sub"),
        STRIKE("del"),
        UNDER("span", "jcreole_underline")  // HTML "u" is deprecated
        ;

        private String tagName, cssClass;
        private InlineMode(String tagName, String cssClass) {
            this.tagName = tagName;
            this.cssClass = cssClass;
        }
        private InlineMode(String tagName) {
            this.tagName = tagName;
        }
        public String getTagName() { return tagName; }
        public String getCssClass() { return cssClass; }
    }

    private WashedSymbol toggleInlineMode(InlineMode mode, Token tok) {
        if (mode == inlineModeStack.peekFirst()) {
            inlineModeStack.pop();
            return new WashedSymbol(
                    markClose(TagType.INLINE) + "</" + mode.getTagName() + '>');
        }
        if (inlineModeStack.contains(mode))
            throw new CreoleParseException("Inline modes are tangled", tok);
        inlineModeStack.push(mode);
        String cssClass = mode.getCssClass();
        return new WashedSymbol("<" + mode.getTagName()
                + ((cssClass == null) ? "" : (" class=\"" + cssClass))
                + markInline(mode.getTagName(), (cssClass == null), false)
                + ((cssClass == null) ? "" : "\"") + '>');
    }

    public WashedSymbol newListNest(List<LiSymbol> liSymbolList) {
        StringBuilder sb = new StringBuilder();
        int curLevel = 0;
        Map<Integer, Character> levelTypeMap =
                new HashMap<Integer, Character>();
        String tagName = null;
        for (LiSymbol liSymbol : liSymbolList) {
            // At each iteration we are either at root (far left col) or
            // we are at the end of a line after li "content".
            tagName = (liSymbol.getType() == '#') ? "ol" : "ul";
            if (liSymbol.getLevel() == curLevel) {
                if (liSymbol.getType()
                        != levelTypeMap.get(curLevel).charValue())
                    throw new CreoleParseException(
                            "Illegal type transition", liSymbol);
                sb.append(markClose(TagType.BLOCK)).append("</li>\n");
            } else if (liSymbol.getLevel() == curLevel + 1) {
                sb.append('<').append(tagName)
                        .append(markBlock(tagName, true, false))
                        .append(">\n");
                levelTypeMap.put(Integer.valueOf(liSymbol.getLevel()),
                        Character.valueOf(liSymbol.getType()));
            } else if (liSymbol.getLevel() < curLevel) {
                sb.append(markClose(TagType.BLOCK)).append("</li>\n");
                for (int hiLevel = curLevel;
                        hiLevel > liSymbol.getLevel(); hiLevel--) {
                    tagName = (levelTypeMap.remove(Integer.valueOf(hiLevel))
                            == '#') ? "ol" : "ul";
                    sb.append(indent(hiLevel-1))
                            .append(markClose(TagType.BLOCK))
                            .append("</").append(tagName).append('>')
                            .append(markClose(TagType.BLOCK))
                            .append("</li>\n");
                }
                if (liSymbol.getType() !=
                        levelTypeMap.get(liSymbol.getLevel()).charValue())
                    throw new CreoleParseException(
                            "Illegal type transition", liSymbol);
            } else {
                throw new CreoleParseException(
                        "Illegal transition from list level "
                        + curLevel + " to " + liSymbol.getLevel(), liSymbol);
            }
            sb.append(indent(liSymbol.getLevel())).append("<li")
                    .append(markBlock("li", true, false)).append('>')
                    .append(liSymbol.getContent());
            curLevel = liSymbol.getLevel();
        }
        sb.append(markClose(TagType.BLOCK)).append("</li>\n");
        for (int hiLevel = curLevel; hiLevel >= 1; hiLevel--) {
            tagName = (levelTypeMap.remove(Integer.valueOf(hiLevel))
                    == '#') ? "ol" : "ul";
            sb.append(indent(hiLevel-1))
                    .append(markClose(TagType.BLOCK))
                    .append("</").append(tagName).append('>');
            if (hiLevel > 1)
                sb.append(markClose(TagType.BLOCK)).append("</li>");
            sb.append('\n');
        }
        return new WashedSymbol(sb.toString());
    }

    private String markBlock(
            String tagName, boolean writeAttr, boolean atomic) {
        BufferMarker bm =
                new BlockMarker(++lastMarkerId, tagName, writeAttr, atomic);
        markers.put(Integer.valueOf(lastMarkerId), bm);
        return bm.getMarkerString();
    }
    private String markInline(
            String tagName, boolean writeAttr, boolean atomic) {
        BufferMarker mI =
                new InlineMarker(++lastMarkerId, tagName, writeAttr, atomic);
        markers.put(Integer.valueOf(lastMarkerId), mI);
        return mI.getMarkerString();
    }
    private String markJcxspan() {
        BufferMarker js = new JcxSpanMarker(++lastMarkerId);
        markers.put(Integer.valueOf(lastMarkerId), js);
        return js.getMarkerString();
    }
    private String markJcxblock() {
        BufferMarker jb = new JcxBlockMarker(++lastMarkerId);
        markers.put(Integer.valueOf(lastMarkerId), jb);
        return jb.getMarkerString();
    }

    private String markClose(TagType targetType) {
        BufferMarker m = new CloseMarker(++lastMarkerId, targetType);
        markers.put(Integer.valueOf(lastMarkerId), m);
        return m.getMarkerString();
    }

    /**
     * TODO:  I just wrote this to get it working now.
     * Can very likely be done much more efficiently and/or elegantly.
     */
    public static String indent(int num) {
        return StringUtils.repeat(INDENT_STRING, num);
    }

    List<Deque<InlineMode>> inlineModeStacks =
            new ArrayList<Deque<InlineMode>>();
    Deque<InlineMode> inlineModeStack = new ArrayDeque<InlineMode>(3);

    {
        inlineModeStacks.add(inlineModeStack);
    }

    private StringBuilder autoCloseInlines() {
        return autoCloseInlines(null);
    }

    private StringBuilder autoCloseInlines(InlineMode untilMode) {
        StringBuilder b = new StringBuilder();
        InlineMode fm;
        while (inlineModeStack.peekFirst() != untilMode)
            b.append("</").append(markClose(TagType.INLINE))
                    .append(inlineModeStack.removeFirst().getTagName())
                    .append('>');
        return b;
    }

    private static final String INDENT_STRING = "  ";

    public WashedSymbol buildTreeSymbol(List<Symbol> symList) {
        //  PHASE 1:  Prepate cell data
        String[][] cells = new String[symList.size()][];
        int i = -1, j, cols = -1;
        for (Symbol rSym : symList) {
            cells[++i] = new String[((List) rSym.value).size()];
            if (cells[i].length > cols) cols = cells[i].length;
            j = -1;
            for (Symbol cTok : (ArrayList<WashedSymbol>) rSym.value)
                cells[i][++j] = cTok.toString();
        }

        // Purposefully not supporting HTML tfoot element, because it's
        // pretty much impossible for it to degrade for non-supporting
        /// browsers.
        // Now break down cells into hCells + bCells (head/body)
        // + bCellIsHead.
        List<String[]> hCellList = null;
        List<String[]> bCellList = null;
        List<boolean[]> bCellIsHead = new ArrayList<boolean[]>();
        boolean[] ih;
        int headCount;
        for (int r = 0; r < cells.length; r++) {
            ih = new boolean[cells[r].length];
            headCount = 0;
            for (int c = 0; c < cells[r].length; c++)
                if (cells[r][c].length() > 0
                        && cells[r][c].charAt(0) == '\u0001') {
                    headCount++;
                    cells[r][c] = cells[r][c].substring(1);
                    ih[c] = true;
                }
            if (headCount == cells[r].length) {
                // All cells in this row are Headings.  Prefer hCells.
                if (bCellList == null) {
                    if (hCellList == null)
                        hCellList = new ArrayList<String[]>();
                    hCellList.add(cells[r]);
                } else {
                    bCellList.add(cells[r]);
                    bCellIsHead.add(ih);
                }
            } else {
                // All cells in this row are not Headings.  Require bCells.
                if (bCellList == null)
                    bCellList = new ArrayList<String[]>();
                bCellList.add(cells[r]);
                bCellIsHead.add(ih);
            }
        }
        if (bCellList != null && bCellList.size() != bCellIsHead.size())
            throw new RuntimeException(
                    "Internal Error.  Mismatch between body row count and "
                    + "body-cell-is-head-count.  " + bCellList.size()
                    + " vs. " + bCellIsHead.size());
        // We have parallel lists that we want to iterate through with
        // index.  This is done more simply with native arrays than lists.
        String[][] hCells = (hCellList == null)
                ? null : hCellList.toArray(new String[0][]);
        String[][] bCells = (bCellList == null)
                ? null : bCellList.toArray(new String[0][]);
        boolean[][] isHead = (bCellIsHead == null)
                ? null : bCellIsHead.toArray(new boolean[0][]);
        if (isHead != null) for (int k = 0; k < isHead.length; k++)
            if (isHead[k].length != bCells[k].length)
                throw new RuntimeException(
                        "Internal Error.  Mismatch between row cell count "
                        + "and row-is-head-count for row #" + (k+1) + ".  "
                        + bCells.length + " vs. " + isHead[k].length);

        //  PHASE 2:  Generate HTML
        StringBuilder sb = new StringBuilder(
                "<table class=\"jcreole_data")
                .append(markBlock("table", false, false)).append("\">\n");
                // 'data' class is to distinguish from formatting tables
                // which may be needed in the future.
        int unfilledCells;
        if (hCells != null) {
            sb.append(indent(1)).append("<thead>");
            for (int r = 0; r < hCells.length; r++) {
                sb.append('\n').append(indent(2)).append("<tr")
                        .append(markBlock("tr", true, false)).append("> ");
                for (int c = 0; c < hCells[r].length; c++) {
                    sb.append("<th");
                    if (c + 1 == hCells[r].length) {
                        unfilledCells = cols - hCells[r].length;
                        if (unfilledCells > 0)
                            sb.append(" colspan=\""
                            + (1+unfilledCells) + '"');
                    }
                    sb.append(markBlock("th", true, false))
                    .append(markClose(TagType.BLOCK))
                    .append('>').append(hCells[r][c]).append("</th>");
                }
                sb.append(markClose(TagType.BLOCK)).append(" </tr>");
            }
            sb.append('\n').append(indent(1)).append("</thead>\n");
        }
        if (bCells != null) {
            sb.append(indent(1)).append("<tbody>");
            String tagName;
            for (int r = 0; r < bCells.length; r++) {
                sb.append('\n').append(indent(2))
                    .append("<tr class=\"jcreole_")
                    .append((r == 2 * (r/2)) ? "even" : "odd").append('"')
                    .append(markBlock("tr", false, false)).append("> ");
                for (int c = 0; c < bCells[r].length; c++) {
                    sb.append("<t").append(isHead[r][c] ? 'h' : 'd');
                    if (c + 1 == bCells[r].length) {
                        unfilledCells = cols - bCells[r].length;
                        if (unfilledCells > 0)
                            sb.append(" colspan=\""
                            + (1+unfilledCells) + '"');
                    }
                    tagName = isHead[r][c] ? "th" : "td";
                    sb.append(markBlock(tagName, true, false))
                    .append('>').append(bCells[r][c]).append("</")
                            .append(markClose(TagType.BLOCK))
                            .append(tagName).append('>');
                }
                sb.append(markClose(TagType.BLOCK)).append(" </tr>");
            }
            sb.append('\n').append(indent(1)).append("</tbody>\n");
        }
        return new WashedSymbol(sb.append(markClose(TagType.BLOCK))
                .append("</table>\n").toString());
    }

    private void require(PluginPrivilege pluginPriv, Symbol s) {
        if (!(s instanceof Token))
            throw new RuntimeException("Symbol not a Token");
        if (!pluginPrivs.contains(pluginPriv))
            throw new CreoleParseException(
                    "You lack the required privilege " + pluginPriv, (Token) s);
    }
:};

%terminals ROOTLVL_PRE, NESTED_PRE, TEXT, HARDSPACE, END_PARA, HARDLINE, HOR;
%terminals URL, IMAGE, LI, END_LI, FINAL_LI, END_ROW, FINAL_ROW, CELL, END_H;
%terminals HEADING, EM_TOGGLE, STRONG_TOGGLE, MONO_TOGGLE, STYLER;
%terminals SUB_TOGGLE, SUP_TOGGLE, UNDER_TOGGLE, STRIKE_TOGGLE;
%terminals JCXSPAN, END_JCXSPAN, JCXBLOCK, END_JCXBLOCK;
%terminals ROOTLVL_HTMLCOMMENT, NESTED_HTMLCOMMENT, ROOTLVL_NEWLINE;
%terminals ROOTLVL_STYLESHEET, NESTED_STYLESHEET;
%terminals ROOTLVL_RAWHTML, NESTED_RAWHTML, TOC, EMDASH;
%terminals ROOTLVL_ENUMFORMATS, NESTED_ENUMFORMATS, ENUMFORMATRESET;

%typeof ROOTLVL_PRE, NESTED_PRE, TEXT, URL, IMAGE, STYLER = "String";
%typeof ROOTLVL_HTMLCOMMENT, NESTED_HTMLCOMMENT, ENUMFORMATRESET = "String";
%typeof ROOTLVL_RAWHTML, NESTED_RAWHTML, ROOTLVL_STYLESHEET, TOC = "String";
%typeof NESTED_STYLESHEET, NESTED_ENUMFORMATS = "String";
%typeof JCXSPAN, JCXBLOCK, ROOTLVL_ENUMFORMATS, jcxblockStart = "String";
%typeof listnest = "WashedSymbol";

%goal blocks;

blocks = topblock.b+ {:
            StringBuilder sb = joinWashedSymbols(_list_b);
            log.debug("PRE-PostProcess[" + sb + ']');
            // Following sets formats for headers and default section labels in
            // TOCs, but has no effect on TOC inclusion.
            return new WashedSymbol(markers.apply(sb, enumerationFormats));
        :}
        | {: return new WashedSymbol("");:};  // This allows for empty document

// Blocks which my only occur at top leve + regular blocks
topblock = HOR {:
            return new WashedSymbol(
                    "<hr" + markBlock("hr", true, true) + ">\n");
        :}
        | HEADING.h hinline.f+ END_H {:
            int hLevel = ((Token) (h)).getIntParam();
            StringBuilder b = joinWashedSymbols(_list_f);
            String labelText = autoLabelText(b.toString());
            String xmlId = mkXmlId(labelText);

            HeadingMarker hm = new HeadingMarker(
                    ++lastMarkerId, xmlId, hLevel, labelText);
            if (formatResetChar != null) {
                hm.setFormatReset(formatResetChar.charValue());
                formatResetChar = null;
            }
            markers.put(Integer.valueOf(lastMarkerId), hm);

            return new WashedSymbol("<h" + hLevel + " id=\"" + xmlId + '"'
                    + hm.getMarkerString()
                    + b + autoCloseInlines()
                    + markClose(TagType.BLOCK)
                    + "</span></h" + hLevel + ">\n");
        :}
        | ROOTLVL_NEWLINE.text {: return new WashedSymbol("\n"); :}
        | masterblock
        | leafblock
        ;

// Blocks which may occur at different levels
masterblock = jcxblock
        | listnest.l {: return new WashedSymbol(l.toString()); :}
        | table.t {: return new WashedSymbol(t.toString()); :}
        ;

// Blocks which may not contain any other block
leafblock = ROOTLVL_PRE.text {:
            return new WashedSymbol("<pre" + markBlock("pre", true, true) + ">\n"
                    + clean(text.replace("\n }}}", "\n}}}")) + "\n</pre>\n");
                // The replace here is for allowing ^}}} inside of pref block.
                // Spec says to do this for all " }}}", but that is
                // unnecessarily liberal since no escaping is needed except
                // for "^ }}}".
        :}
        | ROOTLVL_HTMLCOMMENT.text {:
            if (text.indexOf("--")> -1)
                throw new CreoleParseException(
                        "'--' prohibited inside of XML comments", 
                        (Token) _symbol_text);
            return new WashedSymbol("<!--" + text + "-->");
        :}
        | ROOTLVL_RAWHTML.text {:
            require(PluginPrivilege.RAWHTML, _symbol_text);
            return new WashedSymbol(text);
        :}
        | ROOTLVL_STYLESHEET.text {:
            require(PluginPrivilege.STYLESHEET, _symbol_text);
            cssHrefs.add(clean(absoluteUrl(text)));
            return DUMMY_WASHEDSYMBOL;
        :}
        | ROOTLVL_ENUMFORMATS.text {:
            require(PluginPrivilege.ENUMFORMATS, _symbol_text);
            if (!EnumFormatPattern.matcher(text).matches())
                throw new CreoleParseException(
                        "Malformatted enumFormats: " + text,
                        (Token) _symbol_text);
            if (authorSetEnumFormats)
                throw new CreoleParseException(
                        "Attempted to set enumFormats a second time.  "
                        + "This is a global and location-independent setting, "
                        + "so remove the setting that you don't want.  "
                        + "Use enumFormatReset directive if you want to change "
                        + "formatting in a location-dependent way.",
                        (Token) _symbol_text);
            authorSetEnumFormats = true;
            enumerationFormats = text;
            return DUMMY_WASHEDSYMBOL;
        :}
        | inline.f+ END_PARA.text {:
            StringBuilder b = joinWashedSymbols(_list_f);
            // Purpose of the following is to keep the </p> on same line as
            // the last content of the p.
            int lastI = b.length() - 1;
            if (b.charAt(lastI) == '\n') b.deleteCharAt(lastI);
            return new WashedSymbol("<p" + markBlock("p", true, false)
                    + '>' + b + autoCloseInlines()
                    + markClose(TagType.BLOCK) + "</p>\n");
        :}
        | TOC.text {:
            require(PluginPrivilege.TOC, _symbol_text);
            String classNames = null;
            String sectInclusions = null;
            if (text != null) try {
                Matcher m = SlashDelimitedPattern.matcher(text);
                if (!m.matches() || m.groupCount() != 2)
                    throw new java.lang.Exception("not [x][/y]");
                String str1 = m.group(1);
                String str2 = m.group(2);
                if (str1 != null) classNames = str1.trim();
                if (str2 != null) sectInclusions = str2.trim();
                if (classNames != null
                        && !CssNamesPattern.matcher(classNames).matches())
                    throw new java.lang.Exception("bad CSS Name(s)");
                if (sectInclusions != null
                        && !EnumFormatPattern.matcher(sectInclusions).matches())
                    throw new java.lang.Exception(
                            "bad section-inclusion pattern");
            } catch (java.lang.Exception e) {
                throw new CreoleParseException(
                        "TOC spec. not of format "
                        + "'[class names] [/secinclusions]' ("
                        + e.getMessage() + "):  " + text,
                        (Token) _symbol_text);
            }
            BufferMarker tm = new TocMarker(++lastMarkerId, sectInclusions);
            markers.put(Integer.valueOf(lastMarkerId), tm);
            return new WashedSymbol("<div class=\"jcx_toc"
                    + ((classNames == null) ? "" : (" " + classNames))
                    + "\">\n" + tm.getMarkerString() + "\n</div>\n\n");
        :}
        ;

jcxblockOrInline = jcxblock | inline;

jcxblock = jcxblockStart.classNames jcxblockOrInline.f+ END_JCXBLOCK {:
            StringBuilder b = joinWashedSymbols(_list_f);
            // Purpose of the following is to keep the </div> on same line as
            // the last content of the div.
            int lastI = b.length() - 1;
            if (b.charAt(lastI) == '\n') b.deleteCharAt(lastI);
            b.append(autoCloseInlines().toString());
            inlineModeStacks.remove(0);
            inlineModeStack = inlineModeStacks.get(0);
            return new WashedSymbol("<div class=\"jcx"
                    + ((classNames == null) ? "" : (" " + classNames))
                    + markJcxblock() + "\">" + b
                    + markClose(TagType.JCXBLOCK) + "</div>\n");
        :}
        |  jcxblockStart.classNames END_JCXBLOCK {:
            inlineModeStacks.remove(0);
            inlineModeStack = inlineModeStacks.get(0);
            return new WashedSymbol("<div class=\"jcx"
                    + ((classNames == null) ? "" : (" " + classNames))
                    + markJcxblock() + "\">"
                    + markClose(TagType.JCXBLOCK) + "</div>\n");
        :};

// Only purpose for this one is to push inlineModeStack before the block
// contents are evaluated.
jcxblockStart = JCXBLOCK.text {:
        require(PluginPrivilege.JCXBLOCK, _symbol_text);
        if (text != null && !CssNamesPattern.matcher(text).matches())
            throw new CreoleParseException(
                    "Malformatted class name(s) in JCX directive: " + text,
                    (Token) _symbol_text);
        inlineModeStack = new ArrayDeque<InlineMode>(3);
        inlineModeStacks.add(0, inlineModeStack);
        return _symbol_text;
    :};

table = lastrow.lr {:
            return buildTreeSymbol(Collections.singletonList(lr));
        :}
      | row.rs+ lastrow.lr {:
            _list_rs.add(lr);
            return buildTreeSymbol((List<Symbol>) _list_rs);
        :}
      ;

row   = cell.c+ END_ROW;
lastrow   = cell.c+ FINAL_ROW;
cell  = CELL.c jcxblockOrInline.l+ {: return new WashedSymbol(
                    ((((Token) c).getIntParam() == 1) ? "\u0001" : "")
                    + joinWashedSymbols(_list_l) + autoCloseInlines()); :};

listnest = lastli.llitem {:
                // A single <li> list.
                // Not useful in final docs, but definitely useful for drafts.
                return newListNest(Collections.singletonList((LiSymbol) llitem));
            :}
         | li.litem+ lastli.llitem {:
                List<LiSymbol> liSymbols = (List<LiSymbol>) _list_litem;
                liSymbols.add((LiSymbol) llitem);
                return newListNest(liSymbols);
            :};

li       = liel.li jcxblockOrInline.l+ END_LI {:
                ((LiSymbol) li).setContent(joinWashedSymbols(_list_l).toString()
                        + autoCloseInlines());
                return li;
            :};
lastli   = liel.li jcxblockOrInline.l+ FINAL_LI {:
                ((LiSymbol) li).setContent(joinWashedSymbols(_list_l).toString()
                        + autoCloseInlines());
                return li;
            :};
liel     = LI.listart {: return new LiSymbol((Token) listart); :};

hinline = inline
        | ENUMFORMATRESET.formatStr {:
            require(PluginPrivilege.ENUMFORMATS, _symbol_formatStr);
            if (formatStr.length() != 1)
                throw new CreoleParseException(
                        "Malformatted format char in enumFormatReset "
                        + "directive: " + formatStr,
                        (Token) _symbol_formatStr);
            formatResetChar = Character.valueOf(formatStr.charAt(0));
            return DUMMY_WASHEDSYMBOL;
        :};

inline = NESTED_PRE.text {:
            return new WashedSymbol("<span class=\"jcreole_noWiki"
                    + markInline("span", false, true)
                    + "\">" + clean(text) + "</span>");
        :}
        | NESTED_STYLESHEET.text {:
            require(PluginPrivilege.STYLESHEET, _symbol_text);
            cssHrefs.add(clean(absoluteUrl(text)));
            return DUMMY_WASHEDSYMBOL;
        :}
        | NESTED_ENUMFORMATS.text {:
            require(PluginPrivilege.ENUMFORMATS, _symbol_text);
            if (!EnumFormatPattern.matcher(text).matches())
                throw new CreoleParseException(
                        "Malformatted enumFormats: " + text,
                        (Token) _symbol_text);
            if (authorSetEnumFormats)
                throw new CreoleParseException(
                        "Attempted to set enumFormats a second time.  "
                        + "This is a global and location-independent setting, "
                        + "so remove the setting that you don't want.  "
                        + "Use enumFormatReset directive if you want to change "
                        + "formatting in a location-dependent way.",
                        (Token) _symbol_text);
            authorSetEnumFormats = true;
            enumerationFormats = text;
            return DUMMY_WASHEDSYMBOL;
        :}
        | JCXSPAN.text {:
            require(PluginPrivilege.JCXSPAN, _symbol_text);
            if (text != null && !CssNamesPattern.matcher(text).matches())
                throw new CreoleParseException(
                        "Malformatted class name(s) in JCX directive: " + text,
                        (Token) _symbol_text);
            // N.b. we do not use toggleInlineMode with .JCXSPANs, so
            // InlineMode.tagName and InlineMode.cssClass will not be used.
            inlineModeStack.push(InlineMode.JCXSPAN);
            return new WashedSymbol("<span class=\"jcx"
                    + ((text != null) ? (" " + text) : "")
                    + markJcxspan() + "\">");
        :}
        | END_JCXSPAN.tok {:
            StringBuilder caps = autoCloseInlines(InlineMode.JCXSPAN);
            if (InlineMode.JCXSPAN != inlineModeStack.peekFirst())
                throw new CreoleParseException(
                    "jcxSpan modes are tangled", (Token) tok);
            inlineModeStack.pop();
            return new WashedSymbol(caps.toString()
                    + markClose(TagType.JCXSPAN) + "</span>");
        :}
        | TEXT.f+ {: return mkWashedSymbol((List<String>) _list_f); :}
        | HARDSPACE {: return new WashedSymbol("&nbsp;"); :}
        // For hardline we do not write a \n.  If user wants a \n in addition
        // to the <br>, they should write "<br>\n".
        | HARDLINE {: return new WashedSymbol("<br>"); :}
        | EM_TOGGLE.t {:
            return toggleInlineMode(InlineMode.EMPHASIZED, (Token) t);
        :}
        | STRIKE_TOGGLE.t {:
            return toggleInlineMode(InlineMode.STRIKE, (Token) t);
        :}
        | UNDER_TOGGLE.t {:
            return toggleInlineMode(InlineMode.UNDER, (Token) t);
        :}
        | MONO_TOGGLE.t {:
            return toggleInlineMode(InlineMode.MONO, (Token) t);
        :}
        | SUP_TOGGLE.t {:
            return toggleInlineMode(InlineMode.SUP, (Token) t);
        :}
        | SUB_TOGGLE.t {:
            return toggleInlineMode(InlineMode.SUB, (Token) t);
        :}
        | STRONG_TOGGLE.t {:
            return toggleInlineMode(InlineMode.STRONG, (Token) t);
        :}
        | URL.text {:
            Token token = (Token) _symbol_text;
            int delimPos = token.getIntParam();
            String inLbl = (delimPos > -1)
                         ? text.substring(delimPos + 1) : null;
            String urlText = (delimPos > -1)
                           ? text.substring(0, delimPos) : text;
            String url = null;
            String labelFromMap = null;
            boolean mapLookupFailed = false;
            Matcher matcher = (text.startsWith("http:")
                    || text.startsWith("https:")
                    || text.startsWith("ftp:")) ? null
                    : InterWikiPattern.matcher(urlText);
            // Group 1 is logical wiki name or null
            // Group 2 is required page name
            // Group 3 is optional ?queryString or #anchor
            if (matcher != null && matcher.matches()) {
                if (interWikiMapper == null) {
                    throw new IllegalStateException(String.format(
                    "%s  @line:col %d:%d",
                        "Inter- and Intra-wiki links not supported.",
                        token.getLine() + 1, token.getColumn() + 1));
                }
                url = interWikiMapper.toPath(
                        matcher.group(1), matcher.group(2));
                if (url == null) {
                    mapLookupFailed = true;
                    url = clean(urlText);
                } else if (matcher.group(3) != null) {
                    url += matcher.group(3);
                }
                labelFromMap = (inLbl == null)
                        ? interWikiMapper.toLabel(
                          matcher.group(1), matcher.group(2))
                        : null;
            } else {
                url = clean(absoluteUrl(urlText));
            }
            String label = null;
            if (inLbl == null) {
                if (!pluginPrivs.contains(PluginPrivilege.ABSLINKS)
                        && CreoleParser.isAbsoluteUrl(urlText))
                    return new WashedSymbol(url);
                if (text.startsWith("#" + sectIdPrefix)) {
                    // This defers generation of label text to MarkerMap.
                    BufferMarker m = new LinkMarker(
                            ++lastMarkerId, clean(text));
                    markers.put(Integer.valueOf(lastMarkerId), m);
                    label = m.getMarkerString();
                } else {
                    label = (labelFromMap == null)
                          ? clean(text)
                          : labelFromMap;
                }
            } else {
                // If label is set, then we just can not do anything
                // satisfactory for the page author if they have no ABSLINKS.
                if (!pluginPrivs.contains(PluginPrivilege.ABSLINKS)
                        && CreoleParser.isAbsoluteUrl(urlText))
                    throw new CreoleParseException(
                            "You lack the privilege " + PluginPrivilege.ABSLINKS
                            + " which is require for Absolute linking");
                Matcher m = ImgAsLabelPattern.matcher(inLbl);
                if (m.matches()) {
                    String imgUrl = null;
                    String altText = null;
                    int pipeIndex = m.group(1).indexOf('|');
                    if (pipeIndex > 0) {
                        imgUrl = m.group(1).substring(0, pipeIndex);
                        altText = m.group(1).substring(pipeIndex + 1);
                    } else {
                        imgUrl = m.group(1);
                    }
                    label = "<img src=\"" + clean(absoluteUrl(imgUrl))
                            + '"' + markInline("img", true, true)
                            + ((altText == null) ? ""
                            : (" alt=\"" + altText + '"'))
                            + '>';
                } else {
                    if (text.startsWith("#" + sectIdPrefix)) {
                        // This causese MarkerMap to validate the link
                        LinkMarker lm = new LinkMarker(++lastMarkerId, url);
                        markers.put(Integer.valueOf(lastMarkerId), lm);
                        lm.setLabel(clean(inLbl));
                        label = lm.getMarkerString();
                    } else {
                        label = clean(inLbl);
                    }
                }
            }
            if (mapLookupFailed)
                label = "<span class=\"jcreole_orphanLink\">"
                        + label + "</span>";
            return new WashedSymbol("<a href=\"" + url + '"'
                    + markInline("a", true, true) + '>' + label + "</a>");
        :}
        | IMAGE.text {:
            Token token = (Token) _symbol_text;
            int delimPos = token.getIntParam();
            String url = clean(absoluteUrl(
                    (delimPos > -1) ? text.substring(0, delimPos) : text));
            String alt = (delimPos > -1)
                    ? clean(text.substring(delimPos + 1)) : null;
            return new WashedSymbol("<img src=\"" + url
                + ((alt == null) ? "" : ("\" alt=\"" + alt)) + '"'
                + markInline("img", true, true) + '>');
        :}
        | STYLER.text {:
            require(PluginPrivilege.STYLER, _symbol_text);
            Matcher m = StylerPattern.matcher(text);
            if (!m.matches())
                throw new CreoleParseException(
                        "Malformatted Style specification: " + text,
                        (Token) _symbol_text);
            Styler styler = new Styler(++lastMarkerId, m.group(3),
                    m.group(1).charAt(0), m.group(2));
            markers.put(Integer.valueOf(lastMarkerId), styler);
            return new WashedSymbol(styler.getMarkerString());
        :}
        | NESTED_HTMLCOMMENT.text {:
            if (text.indexOf("--")> -1)
                throw new CreoleParseException(
                        "'--' prohibited inside of XML comments",
                        (Token) _symbol_text);
            return new WashedSymbol("<!--" + text + "-->");
        :}
        | NESTED_RAWHTML.text {:
            require(PluginPrivilege.RAWHTML, _symbol_text);
            return new WashedSymbol(text);
        :}
        | EMDASH {: return new WashedSymbol("&#x2014;"); :}
        ;
