/*
 * Copyright 2011 Axis Data Management Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


%package "com.admc.jcreole";

%import "java.net.URL";
%import "java.net.MalformedURLException";
%import "java.util.regex.Pattern";
%import "java.util.List";
%import "java.util.Map";
%import "java.util.HashMap";
%import "java.util.regex.Matcher";
%import "java.util.Deque";
%import "java.util.ArrayDeque";
%import "java.util.Collections";
%import "org.apache.commons.logging.Log";
%import "org.apache.commons.logging.LogFactory";
%import "org.apache.commons.lang.StringEscapeUtils";
%import "org.apache.commons.lang.StringUtils";
%import "com.admc.jcreole.marker.*";

%embed {:
    private static Log log = LogFactory.getLog(CreoleParser.class);

    private boolean wrote;  // Just used to write block-separating blank lines
    // TODO:  urlBase and pathBase need to be instance vars set by setter or
    //        constructor param.
    // TODO:  Think about whether this generous whitespace stripping is ok.
    private static Pattern ImgAsLabelPattern =
            Pattern.compile("\\s*\\Q{{\\E\\s*(.+?)\\s*\\Q}}\\E\\s*");
    private static Pattern IntraWikiPattern = Pattern.compile("([^:]+):(.+)");
    private String urlBase;
    private String pathBase;
    // Following is just for testing.
    // Before use this class in a real product, remove the assignment so it
    // will default to null, thereby disabling intra-wiki linking.
    // (Integrators will the use the setter to enable intra-wiki linking).
    private IntraWikiMapper intraWikiMapper = new IntraWikiMapper() {
        public String toPath(String wikiName, String wikiPage) {
            return "{" + wikiName + '/' + wikiPage + '}';
        }
    };
    private int lastMarkerId = 0;
    private MarkerMap markers = new MarkerMap();

    /**
     * Assign a mapper from wiki page names to actual paths or URLs to the
     * pages.
     *
     * @see IntraWikiMapper
     */
    public void setIntraWikiMapper(IntraWikiMapper intraWikiMapper) {
        this.intraWikiMapper = intraWikiMapper;
    }

    /**
     * Use this method and setPathBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setUrlBase(String urlBase) {
        this.urlBase = urlBase;
    }

    /**
     * Use this method and setUrlBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setPathBase(String pathBase) {
        this.pathBase = pathBase;
    }

    /**
     * Returns a single XML-washed String
     *
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     * The specified List must be all WashedSymbols.
     */
    public static StringBuilder joinWashedSymbols(List<WashedSymbol> wtList) {
        StringBuilder sb = new StringBuilder();
        for (WashedSymbol t : wtList) sb.append(t.toString());
        return sb;
    }

    /**
     * Returns a single XML-washed String
     *
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     * The specified List must be either all non-washed Tokens.
     */
    public static WashedSymbol mkWashedSymbol(List<String> sList) {
        //@SuppressWarnings("unchecked")
        StringBuilder sb = new StringBuilder();
        for (String s : sList) sb.append(s);
        return new WashedSymbol(clean(sb.toString()));
    }

    private String absoluteUrl(String path) {
        if (urlBase == null && pathBase == null) return path;
        if (path.length() > 0 && path.charAt(0) == '/') {
            return urlBase + path;
        } else try {
            new URL(path);
        } catch (MalformedURLException mue) {
            return ((urlBase == null) ? "" : urlBase)
                    + ((pathBase == null) ? "" : pathBase) + '/' +  path;
        }
        return path;
    }

    private WashedSymbol blockToken(String s) {
        if (wrote) return new WashedSymbol("\n" + s);
        wrote = true;
        return new WashedSymbol(s);
    }

    /**
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     *
     * Preserves &...; entities in input but otherwise applies new entities to
     * escape special HTML characters.
     */
    public static String clean(String s) {
        return StringEscapeUtils.escapeHtml(s.replaceAll("&(?=\\w+;)", "\b"))
                .replace('\b', '&');
    }

    private enum FontMode {
        EMPHASIZED("em"), STRONG("strong");
        private String tagName;
        private FontMode(String tagName) { this.tagName = tagName; }
        public String toString() { return tagName; }
    }

    public WashedSymbol newListNest(List<LiSymbol> liSymbolList) {
        StringBuilder sb = new StringBuilder();
        int curLevel = 0;
        Map<Integer, Character> levelTypeMap =
                new HashMap<Integer, Character>();
        String tagName = null;
        for (LiSymbol liSymbol : liSymbolList) {
            tagName = (liSymbol.getType() == '#') ? "ol" : "ul";
            if (liSymbol.getLevel() == curLevel + 1) {
                sb.append(indent(liSymbol.getLevel()-1))
                        .append('<')
                        .append(tagName)
                        .append(markBlock(tagName, true, false))
                        .append(">\n");
                levelTypeMap.put(Integer.valueOf(liSymbol.getLevel()),
                        Character.valueOf(liSymbol.getType()));
            } else if (liSymbol.getLevel() < curLevel) {
                for (int hiLevel = curLevel;
                        hiLevel > liSymbol.getLevel(); hiLevel--) {
                    tagName = (levelTypeMap.remove(Integer.valueOf(hiLevel))
                            == '#') ? "ol" : "ul";
                    sb.append(indent(hiLevel-1)).append("</").append(tagName)
                            .append(markClose(tagName, true)).append(">\n");
                }
                if (liSymbol.getType() !=
                        levelTypeMap.get(liSymbol.getLevel()).charValue())
                    throw new CreoleParseException(
                            "Illegal type transition", liSymbol);
            } else if (liSymbol.getLevel() == curLevel) {
                // All we do in this case is to validate the type.
                if (liSymbol.getType() != levelTypeMap.get(curLevel).charValue())
                    throw new CreoleParseException(
                            "Illegal type transition", liSymbol);
            } else {
                throw new CreoleParseException(
                        "Illegal transition from list level "
                        + curLevel + " to " + liSymbol.getLevel(), liSymbol);
            }
            sb.append(indent(liSymbol.getLevel())).append("<li")
                    .append(markBlock("li", true, false)).append('>')
                    .append(liSymbol.getContent())
                    .append(markClose("li", true)).append("</li>\n");
            curLevel = liSymbol.getLevel();
        }
        for (int hiLevel = curLevel; hiLevel > 0; hiLevel--) {
            tagName = (levelTypeMap.remove(Integer.valueOf(hiLevel))
                    == '#') ? "ol" : "ul";
            sb.append(indent(hiLevel-1)).append("</")
                    .append(markClose(tagName, true))
                    .append(tagName).append(">\n");
        }
        return new WashedSymbol(sb.toString());
    }

    private String markBlock(
            String tagName, boolean writeAttr, boolean atomic) {
        BufferMarker cI =
                new BlockMarker(++lastMarkerId, tagName, writeAttr, atomic);
        markers.put(Integer.valueOf(lastMarkerId), cI);
        return cI.getMarkerString();
    }
    private String markInline(
            String tagName, boolean writeAttr, boolean atomic) {
        BufferMarker cI =
                new InlineMarker(++lastMarkerId, tagName, writeAttr, atomic);
        markers.put(Integer.valueOf(lastMarkerId), cI);
        return cI.getMarkerString();
    }
    private String markJcxSpan() {
        BufferMarker cI = new JcxSpanMarker(++lastMarkerId);
        markers.put(Integer.valueOf(lastMarkerId), cI);
        return cI.getMarkerString();
    }

    private String markClose() {
        BufferMarker m = new CloseMarker(++lastMarkerId);
        markers.put(Integer.valueOf(lastMarkerId), m);
        return m.getMarkerString();
    }
    private String markClose(String tagName, boolean isBlockType) {
        BufferMarker m = new CloseMarker(++lastMarkerId, tagName, isBlockType);
        markers.put(Integer.valueOf(lastMarkerId), m);
        return m.getMarkerString();
    }

    /**
     * TODO:  I just wrote this to get it working now.
     * Can very likely be done much more efficiently and/or elegantly.
     */
    public static String indent(int num) {
        return StringUtils.repeat(INDENT_STRING, num);
    }

    Deque<FontMode> fontModeStack = new ArrayDeque<FontMode>(2);

    private StringBuilder fontCaps() {
        StringBuilder b = new StringBuilder();
        FontMode fm;
        String tagName;
        while (fontModeStack.peekFirst() != null) {
            tagName = fontModeStack.removeFirst().toString();
            b.append("</").append(markClose(tagName, false))
                    .append(tagName).append('>');
        }
        return b;
    }

    private static final String INDENT_STRING = "  ";

    public WashedSymbol buildTreeSymbol(List<Symbol> symList) {
        //  PHASE 1:  Prepate cell data
        String[][] cells = new String[symList.size()][];
        int i = -1, j, cols = -1;
        for (Symbol rSym : symList) {
            cells[++i] = new String[((List) rSym.value).size()];
            if (cells[i].length > cols) cols = cells[i].length;
            j = -1;
            for (Symbol cTok : (ArrayList<WashedSymbol>) rSym.value)
                cells[i][++j] = cTok.toString();
        }

        // Purposefully not supporting HTML tfoot element, because it's
        // pretty much impossible for it to degrade for non-supporting
        /// browsers.
        // Now break down cells into hCells + bCells (head/body)
        // + bCellIsHead.
        List<String[]> hCellList = null;
        List<String[]> bCellList = null;
        List<boolean[]> bCellIsHead = new ArrayList<boolean[]>();
        boolean[] ih;
        int headCount;
        for (int r = 0; r < cells.length; r++) {
            ih = new boolean[cells[r].length];
            headCount = 0;
            for (int c = 0; c < cells[r].length; c++)
                if (cells[r][c].length() > 0
                        && cells[r][c].charAt(0) == '\u0001') {
                    headCount++;
                    cells[r][c] = cells[r][c].substring(1);
                    ih[c] = true;
                }
            if (headCount == cells[r].length) {
                // All cells in this row are Headings.  Prefer hCells.
                if (bCellList == null) {
                    if (hCellList == null)
                        hCellList = new ArrayList<String[]>();
                    hCellList.add(cells[r]);
                } else {
                    bCellList.add(cells[r]);
                    bCellIsHead.add(ih);
                }
            } else {
                // All cells in this row are not Headings.  Require bCells.
                if (bCellList == null)
                    bCellList = new ArrayList<String[]>();
                bCellList.add(cells[r]);
                bCellIsHead.add(ih);
            }
        }
        if (bCellList != null && bCellList.size() != bCellIsHead.size())
            throw new RuntimeException(
                    "Internal Error.  Mismatch between body row count and "
                    + "body-cell-is-head-count.  " + bCellList.size()
                    + " vs. " + bCellIsHead.size());
        // We have parallel lists that we want to iterate through with
        // index.  This is done more simply with native arrays than lists.
        String[][] hCells = (hCellList == null)
                ? null : hCellList.toArray(new String[0][]);
        String[][] bCells = (bCellList == null)
                ? null : bCellList.toArray(new String[0][]);
        boolean[][] isHead = (bCellIsHead == null)
                ? null : bCellIsHead.toArray(new boolean[0][]);
        if (isHead != null) for (int k = 0; k < isHead.length; k++)
            if (isHead[k].length != bCells[k].length)
                throw new RuntimeException(
                        "Internal Error.  Mismatch between row cell count "
                        + "and row-is-head-count for row #" + (k+1) + ".  "
                        + bCells.length + " vs. " + isHead[k].length);

        //  PHASE 2:  Generate HTML
        StringBuilder sb = new StringBuilder(
                "<table class=\"jcreole_data")
                .append(markBlock("table", false, false)).append("\">\n");
                // 'data' class is to distinguish from formatting tables
                // which may be needed in the future.
        int unfilledCells;
        if (hCells != null) {
            sb.append(indent(1)).append("<thead>");
            for (int r = 0; r < hCells.length; r++) {
                sb.append('\n').append(indent(2)).append("<tr")
                        .append(markBlock("tr", true, false)).append("> ");
                for (int c = 0; c < hCells[r].length; c++) {
                    sb.append("<th");
                    if (c + 1 == hCells[r].length) {
                        unfilledCells = cols - hCells[r].length;
                        if (unfilledCells > 0)
                            sb.append(" colspan=\""
                            + (1+unfilledCells) + '"');
                    }
                    sb.append(markBlock("th", true, false))
                    .append(markClose("th", true))
                    .append('>').append(hCells[r][c]).append("</th>");
                }
                sb.append(markClose("tr", true)).append(" </tr>");
            }
            sb.append('\n').append(indent(1)).append("</thead>\n");
        }
        if (bCells != null) {
            sb.append(indent(1)).append("<tbody>");
            String tagName;
            for (int r = 0; r < bCells.length; r++) {
                sb.append('\n').append(indent(2))
                    .append("<tr class=\"jcreole_")
                    .append((r == 2 * (r/2)) ? "even" : "odd").append('"')
                    .append(markBlock("tr", false, false)).append("> ");
                for (int c = 0; c < bCells[r].length; c++) {
                    sb.append("<t").append(isHead[r][c] ? 'h' : 'd');
                    if (c + 1 == bCells[r].length) {
                        unfilledCells = cols - bCells[r].length;
                        if (unfilledCells > 0)
                            sb.append(" colspan=\""
                            + (1+unfilledCells) + '"');
                    }
                    tagName = isHead[r][c] ? "th" : "td";
                    sb.append(markBlock(tagName, true, false))
                    .append('>').append(bCells[r][c]).append("</")
                            .append(markClose(tagName, true))
                            .append(tagName).append('>');
                }
                sb.append(markClose("tr", true)).append(" </tr>");
            }
            sb.append('\n').append(indent(1)).append("</tbody>\n");
        }
        return new WashedSymbol(sb.append("</table>\n").toString());
    }
:};

%terminals BLOCK_PRE, INLINE_PRE, TEXT, HARDSPACE, END_PARA, HARDLINE, HOR;
%terminals URL, IMAGE, LI, END_LI, FINAL_LI, END_ROW, FINAL_ROW, CELL, END_H;
%terminals HEADING, EM_TOGGLE, STRONG_TOGGLE, SPAN, END_SPAN;

%typeof BLOCK_PRE, INLINE_PRE, TEXT, URL, IMAGE = "String";
%typeof listnest = "WashedSymbol";

%goal blocks;

/* The grammar */
blocks = block.b+ {:
            StringBuilder sb = joinWashedSymbols(_list_b)
                    .insert(0, "<div class=\"jcreole\">\n")
                    .append("</div>\n");
            log.debug("PRE-PostProcess[" + sb + ']');
            return new WashedSymbol(markers.apply(sb));
        :}
        |;  // This last allows for empty document

block = isoblock.f+ {:
            return new WashedSymbol(joinWashedSymbols(_list_f).toString());
        :}
        | inline.f+ END_PARA {:
            StringBuilder b = joinWashedSymbols(_list_f);
            int lastI = b.length() - 1;
            if (b.charAt(lastI) == '\n') b.deleteCharAt(lastI);
            return blockToken("<p" + markBlock("p", true, false)
                    + '>' + b + fontCaps() + markClose("p", true) + "</p>\n");
        :}
        | listnest.l {: return blockToken(l.toString()); :}
        | table.t {: return blockToken(t.toString()); :}
        | HEADING.h inline.f+ END_H {:
            int hLevel = ((Token) (h)).getIntParam();
            StringBuilder b = joinWashedSymbols(_list_f);
            //int lastI = b.length() - 1;
            //if (b.charAt(lastI) == '\n') b.deleteCharAt(lastI);
            return blockToken("<h" + hLevel
                    + markBlock("h" + hLevel, true, true) + '>'
                    + b + fontCaps() + "</h" + hLevel + ">\n");
        :}
        ;

table = lastrow.lr {:
            return buildTreeSymbol(Collections.singletonList(lr));
        :}
      | row.rs+ lastrow.lr {:
            _list_rs.add(lr);
            return buildTreeSymbol((List<Symbol>) _list_rs);
        :}
      ;

row   = cell.c+ END_ROW;
lastrow   = cell.c+ FINAL_ROW;
cell  = CELL.c inline.l+ {: return new WashedSymbol(
                    ((((Token) c).getIntParam() == 1) ? "\u0001" : "")
                    + joinWashedSymbols(_list_l) + fontCaps()); :};

listnest = lastli.llitem {:
                // A single <li> list.
                // Not useful in final docs, but definitely useful for drafts.
                return newListNest(Collections.singletonList((LiSymbol) llitem));
            :}
         | li.litem+ lastli.llitem {:
                List<LiSymbol> liSymbols = (List<LiSymbol>) _list_litem;
                liSymbols.add((LiSymbol) llitem);
                return newListNest(liSymbols);
            :};

li       = liel.li inline.l+ END_LI {:
                ((LiSymbol) li).setContent(joinWashedSymbols(_list_l).toString()
                        + fontCaps());
                return li;
            :};
lastli   = liel.li inline.l+ FINAL_LI {:
                ((LiSymbol) li).setContent(joinWashedSymbols(_list_l).toString()
                        + fontCaps());
                return li;
            :};
liel     = LI.listart {: return new LiSymbol((Token) listart); :};

inline = INLINE_PRE.text {:
            return new WashedSymbol("<span class=\"jcreole_pref"
                    + markInline("span", false, true)
                    + "\">" + clean(text) + "</span>");
        :}
        | SPAN {:
            return new WashedSymbol("<span class=\"jcx"
                    + markJcxSpan() + "\">");
        :}
        | END_SPAN {:
            return new WashedSymbol(markClose() + "</span>");
        :}
        | TEXT.f+ {: return mkWashedSymbol((List<String>) _list_f); :}
        | HARDSPACE {: return new WashedSymbol("&nbsp;"); :}
        // For hardline we do not write a \n.  If user wants a \n in addition
        // to the <br>, they should write "<br>\n".
        | HARDLINE {: return new WashedSymbol("<br>"); :}
        | EM_TOGGLE.t {:
            Token token = (Token) t;
            if (FontMode.EMPHASIZED.equals(fontModeStack.peekFirst())) {
                fontModeStack.pop();
                return new WashedSymbol(markClose("em", false) + "</em>");
            }
            if (fontModeStack.contains(FontMode.EMPHASIZED))
                throw new CreoleParseException(
                        "Font presentations modes are tangled", token);
            fontModeStack.push(FontMode.EMPHASIZED);
            return new WashedSymbol("<em" + markInline("em", true, false) + '>');
        :}
        | STRONG_TOGGLE.t {:
            Token token = (Token) t;
            if (FontMode.STRONG.equals(fontModeStack.peekFirst())) {
                fontModeStack.pop();
                return new WashedSymbol(
                        markClose("strong", false) + "</strong>");
            }
            if (fontModeStack.contains(FontMode.STRONG))
                throw new CreoleParseException(
                        "Font presentations modes are tangled", token);
            fontModeStack.push(FontMode.STRONG);
            return new WashedSymbol(
                    "<strong" + markInline("strong", true, false) + '>');
        :}
        | URL.text {:
            Token token = (Token) _symbol_text;
            int delimPos = token.getIntParam();
            String inLbl = (delimPos > -1)
                         ? text.substring(delimPos + 1) : null;
            String urlText = (delimPos > -1)
                           ? text.substring(0, delimPos) : text;
            String url = null;
            Matcher matcher = (text.startsWith("http:")
                    || text.startsWith("https:")
                    || text.startsWith("ftp:")) ? null
                    : IntraWikiPattern.matcher(urlText);
            if (matcher != null && matcher.matches()) {
                if (intraWikiMapper == null) {
                    throw new IllegalStateException(String.format(
                    "%s  @line:col %d:%d",
                        "Intra-wiki links not supported.",
                        token.getLine() + 1, token.getColumn() + 1));
                }
                url = intraWikiMapper.toPath(
                        matcher.group(1), matcher.group(2));
            } else {
                url = clean(absoluteUrl(urlText));
            }
            String label = null;
            if (inLbl == null) {
                label = clean(text);
            } else {
                Matcher m = ImgAsLabelPattern.matcher(inLbl);
                label = m.matches()
                    ? ("<img src=\"" + clean(absoluteUrl(m.group(1))) + '"'
                            + markInline("img", true, true) + '>')
                    : clean(inLbl);
            }
            return new WashedSymbol("<a href=\"" + url + '"'
                    + markInline("a", true, true) + '>' + label + "</a>");
        :}
        | IMAGE.text {:
            Token token = (Token) _symbol_text;
            int delimPos = token.getIntParam();
            String url = clean(absoluteUrl(
                    (delimPos > -1) ? text.substring(0, delimPos) : text));
            String alt = (delimPos > -1)
                    ? clean(text.substring(delimPos + 1)) : null;
            return new WashedSymbol("<img src=\"" + url
                + ((alt == null) ? "" : ("\" alt=\"" + alt)) + '"'
                + markInline("img", true, true) + '>');
        :}
        ;

// These may not contain any inlines
isoblock = HOR {:
            return blockToken("<hr" + markBlock("hr", true, true) + ">\n");
          :}
        | BLOCK_PRE.text {:
            return blockToken("<pre" + markBlock("pre", true, true) + ">\n"
                    + clean(text.replace("\n }}}", "\n}}}")) + "\n</pre>\n");
                // The replace here is for allowing ^}}} inside of pref block.
                // Spec says to do this for all " }}}", but that is
                // unnecessarily liberal since no escaping is needed except
                // for "^ }}}".
        :}
        ;
