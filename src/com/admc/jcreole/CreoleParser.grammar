%package "com.admc.jcreole";

%import "java.util.List";
%import "java.util.regex.Pattern";
%import "java.util.regex.Matcher";
%import "java.net.URL";
%import "java.net.MalformedURLException";
%import "org.apache.commons.lang.StringEscapeUtils";

%embed {:
    private boolean validateOnly;
    private boolean wrote;  // Just used to write block-separating blank lines
    // TODO:  urlBase and pathBase need to be instance vars set by setter or
    //        constructor param.
    // TODO:  Think about whether this generous whitespace stripping is ok.
    private static Pattern LabelPattern =
            Pattern.compile("\\s*\\Q{{\\E\\s*(.+?)\\s*\\Q}}\\E\\s*");
    private static Pattern IntraWikiPattern = Pattern.compile("([^:]+):(.+)");
    private String urlBase;
    private String pathBase;
    private StringBuilder sb = new StringBuilder();
    // Following is just for testing.
    // Before use this class in a real product, remove the assignment so it
    // will default to null, thereby disabling intra-wiki linking.
    // (Integrators will the use the setter to enable intra-wiki linking).
    private IntraWikiMapper intraWikiMapper = new IntraWikiMapper() {
        public String toPath(String wikiName, String wikiPage) {
            return "{" + wikiName + '/' + wikiPage + '}';
        }
    };
    public void setValidateOnly(boolean validateOnly) {
        this.validateOnly = validateOnly;
    }
    public void out(String s) {
        if (validateOnly) return;
        sb.append(s);
        sb.append('\n');
    }
    /*  I believe our scanner will always provide Strings, so we'll never need
     *  to write individual chars.
    public void out(char c) {
        if (validateOnly) return;
        sb.append(c);
        sb.append('\n');
    }
    */
    public String getOutput() {
        return sb.toString();
    }

    public void setIntraWikiMapper(IntraWikiMapper intraWikiMapper) {
        this.intraWikiMapper = intraWikiMapper;
    }

    /**
     * Use this method and setPathBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setUrlBase(String urlBase) {
        this.urlBase = urlBase;
    }

    /**
     * Use this method and setUrlBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setPathBase(String pathBase) {
        this.pathBase = pathBase;
    }

    /**
     * Returns a single XML-washed String
     */
    public static StringBuilder concat(List inList) {
        @SuppressWarnings("unchecked")
        List<Symbol> symList = (List<Symbol>) inList;
        Token t;
        StringBuilder sb = new StringBuilder();
        for (Symbol s : symList) {
            if (!(s instanceof Token))
                throw new IllegalStateException(
                        "element not a Token but a "
                        + s.getClass().getName());
            t = (Token) s;
            if (!(t instanceof WashedToken) && !(t.value instanceof String))
                throw new IllegalStateException(
                        "element value not a String but a "
                        + t.value.getClass().getName());
            sb.append((t instanceof WashedToken)
                    ? ((WashedToken) t).getCleanString()
                    : StringEscapeUtils.escapeHtml(t.getStringVal()));
        }
        return sb;
    }

    private String absoluteUrl(String path) {
        if (urlBase == null && pathBase == null) return path;
        if (path.length() > 0 && path.charAt(0) == '/') {
            return urlBase + path;
        } else try {
            new URL(path);
        } catch (MalformedURLException mue) {
            return ((urlBase == null) ? "" : urlBase)
                    + ((pathBase == null) ? "" : pathBase) + '/' +  path;
        }
        return path;
    }

    private WashedToken blockToken(String s) {
        if (wrote) return new WashedToken("\n" + s);
        wrote = true;
        return new WashedToken(s);
    }
:};

%terminals BLOCK_PRE, INLINE_PRE, TEXT, HARDSPACE, END_PARA, HARDLINE, HOR;
%terminals URL, IMAGE, OLI, ULI, END_LI, FINAL_LI;
%terminals H1, H2, H3, H4, H5, H6;

%typeof BLOCK_PRE, INLINE_PRE, TEXT, URL, IMAGE = "String";
%typeof H1, H2, H3, H4, H5, H6 = "String";
%typeof list = "WashedToken";

%goal blocks;

/* The grammar */
blocks = block.b+ {:
            return new WashedToken(concat(_list_b).toString());
        :}
        |;  // This last allows for empty document

block = isoblock.f+ {:
            return new WashedToken(concat(_list_f).toString());
        :}
        | inline.f+ END_PARA {:
            if (((Symbol) _list_f.get(f.length-1)).value.equals("\n"))
                _list_f.remove(f.length-1);
            return blockToken("<p>" + concat(_list_f) + "</p>\n");
        :}
        | list.l {:
            return blockToken("<ul>" + l.getCleanString() + "</ul>\n");
        :}
        ;

list     = li.l+ liel inline.f+ FINAL_LI {:
            return new WashedToken(concat(_list_l) + "<li>" + concat(_list_f) + "</li>\n");
            :}
         | liel inline.f+ FINAL_LI {:
            return new WashedToken("<li>" + concat(_list_f) + "</li>\n");
            :};
li       = liel inline.l+ END_LI {:
            return new WashedToken("<li>" + concat(_list_l) + "</li>\n");
            :};
liel     = OLI | ULI;

inline = INLINE_PRE.text {:
            return new WashedToken("<span class=\"jcreole_pref\">"
                    + StringEscapeUtils.escapeHtml(text) + "</span>");
        :}
        | TEXT
        | HARDSPACE {: return new WashedToken("&nbsp;"); :}
        // For hardline we do not write a \n.  If user wants a \n in addition
        // to the <br>, they should write "<br>\n".
        | HARDLINE {: return new WashedToken("<br>"); :}
        | URL.text {:
            int nullPos = text.indexOf('\0');
            String url = null;
            Matcher matcher = (text.startsWith("http:")
                    || text.startsWith("https:")
                    || text.startsWith("ftp:")) ? null
                    : IntraWikiPattern.matcher(text);
            if (matcher != null && matcher.matches()) {
                if (intraWikiMapper == null)
                    throw new IllegalArgumentException(
                            "Intra-wiki links not supported");
                url = intraWikiMapper.toPath(
                        matcher.group(1), matcher.group(2));
            } else {
                url = StringEscapeUtils.escapeHtml(absoluteUrl(
                    (nullPos > -1) ? text.substring(0, nullPos) : text));
            }
            String inLbl = (nullPos > -1) ? text.substring(nullPos + 1) : null;
            String label = null;
            if (inLbl == null) {
                label = StringEscapeUtils.escapeHtml(text);
            } else {
                Matcher m = LabelPattern.matcher(inLbl);
                label = m.matches()
                    ? ("<img src=\""
                            + StringEscapeUtils.escapeHtml(
                            absoluteUrl(m.group(1))) + "\">")
                    : StringEscapeUtils.escapeHtml(inLbl);
            }
            return new WashedToken("<a href=\"" + url + "\">" + label + "</a>");
        :}
        | IMAGE.text {:
            int nullPos = text.indexOf('\0');
            String url = StringEscapeUtils.escapeHtml(absoluteUrl(
                    (nullPos > -1) ? text.substring(0, nullPos) : text));
            String alt = (nullPos > -1) ? text.substring(nullPos + 1) : null;
            return new WashedToken("<img src=\"" + url
                + ((alt == null) ? "" : ("\" alt=\"" + alt)) + "\">");
        :}
        ;

// These may not contain any inlines
isoblock = HOR {: return blockToken("<hr>\n"); :}
        | H1.text {: return blockToken("<h1>"
                + StringEscapeUtils.escapeHtml(text) + "</h1>\n");
        :}
        | H2.text {: return blockToken("<h2>"
                + StringEscapeUtils.escapeHtml(text) + "</h2>\n");
        :}
        | H3.text {: return blockToken("<h3>"
                + StringEscapeUtils.escapeHtml(text) + "</h3>\n");
        :}
        | H4.text {: return blockToken("<h4>"
                + StringEscapeUtils.escapeHtml(text) + "</h4>\n");
        :}
        | H5.text {: return blockToken("<h5>"
                + StringEscapeUtils.escapeHtml(text) + "</h5>\n");
        :}
        | H6.text {: return blockToken("<h6>"
                + StringEscapeUtils.escapeHtml(text) + "</h6>\n");
        :}
        | BLOCK_PRE.text {: return blockToken("<pre>\n"
                + StringEscapeUtils.escapeHtml(
                text.replace("\n }}}", "\n}}}")) + "\n</pre>\n");
                // The replace here is for allowing ^}}} inside of pref block.
                // Spec says to do this for all " }}}", but that is
                // unnecessarily liberal since no escaping is needed except
                // for "^ }}}".
        :}
        ;
