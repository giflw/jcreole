%package "com.admc.jcreole";

%import "java.net.URL";
%import "java.net.MalformedURLException";
%import "org.apache.commons.lang.StringEscapeUtils";
%import "java.util.regex.Pattern";
%import "java.util.List";
%import "java.util.Map";
%import "java.util.HashMap";
%import "java.util.regex.Matcher";
%import "java.util.Deque";
%import "java.util.ArrayDeque";
%import "java.util.Collections";

%embed {:
    private boolean validateOnly;
    private boolean wrote;  // Just used to write block-separating blank lines
    // TODO:  urlBase and pathBase need to be instance vars set by setter or
    //        constructor param.
    // TODO:  Think about whether this generous whitespace stripping is ok.
    private static Pattern LabelPattern =
            Pattern.compile("\\s*\\Q{{\\E\\s*(.+?)\\s*\\Q}}\\E\\s*");
    private static Pattern IntraWikiPattern = Pattern.compile("([^:]+):(.+)");
    private String urlBase;
    private String pathBase;
    // Following is just for testing.
    // Before use this class in a real product, remove the assignment so it
    // will default to null, thereby disabling intra-wiki linking.
    // (Integrators will the use the setter to enable intra-wiki linking).
    private IntraWikiMapper intraWikiMapper = new IntraWikiMapper() {
        public String toPath(String wikiName, String wikiPage) {
            return "{" + wikiName + '/' + wikiPage + '}';
        }
    };
    public void setValidateOnly(boolean validateOnly) {
        this.validateOnly = validateOnly;
    }

    public void setIntraWikiMapper(IntraWikiMapper intraWikiMapper) {
        this.intraWikiMapper = intraWikiMapper;
    }

    /**
     * Use this method and setPathBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setUrlBase(String urlBase) {
        this.urlBase = urlBase;
    }

    /**
     * Use this method and setUrlBase to absolutize link and image URLs.
     * It is usually better to let HTML behavior absolutize these as it is
     * designed to do.
     */
    public void setPathBase(String pathBase) {
        this.pathBase = pathBase;
    }

    /**
     * Returns a single XML-washed String
     *
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     * The specified List must be either all WashedTokens or all non-washed
     * Tokens.  No mixing.
     */
    public static StringBuilder joinWashedTokens(List<WashedToken> wtList) {
        StringBuilder sb = new StringBuilder();
        for (WashedToken t : wtList) sb.append(t.toString());
        return sb;
    }

    /**
     * Returns a single XML-washed String
     *
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     * The specified List must be either all WashedTokens or all non-washed
     * Tokens.  No mixing.
     */
    public static WashedToken mkWashedToken(List<String> sList) {
        //@SuppressWarnings("unchecked")
        StringBuilder sb = new StringBuilder();
        for (String s : sList) sb.append(s);
        return new WashedToken(clean(sb.toString()));
    }

    private String absoluteUrl(String path) {
        if (urlBase == null && pathBase == null) return path;
        if (path.length() > 0 && path.charAt(0) == '/') {
            return urlBase + path;
        } else try {
            new URL(path);
        } catch (MalformedURLException mue) {
            return ((urlBase == null) ? "" : urlBase)
                    + ((pathBase == null) ? "" : pathBase) + '/' +  path;
        }
        return path;
    }

    private WashedToken blockToken(String s) {
        if (wrote) return new WashedToken("\n" + s);
        wrote = true;
        return new WashedToken(s);
    }

    /**
     * Uses character \b internally so INPUT STRING MAY NOT CONTAIN \b!
     *
     * Preserves &...; entities in input but otherwise applies new entities to
     * escape special HTML characters.
     */
    public static String clean(String s) {
        return StringEscapeUtils.escapeHtml(s.replaceAll("&(?=\\w+;)", "\b"))
                .replace('\b', '&');
    }

    private enum FontMode {
        EMPHASIZED("em"), STRONG("strong");
        private String tagName;
        private FontMode(String tagName) { this.tagName = tagName; }
        public String toString() { return tagName; }
    }

    public WashedToken newListNest(List<LiToken> liTokenList) {
        StringBuilder sb = new StringBuilder();
        int curLevel = 0;
        Map<Integer, Character> levelTypeMap =
                new HashMap<Integer, Character>();
        for (LiToken liToken : liTokenList) {
            if (liToken.getLevel() == curLevel + 1) {
                sb.append(spaces(liToken.getLevel()-1)
                        + '<' + ((liToken.getType() == '#') ? "ol" : "ul")
                        + ">\n");
                levelTypeMap.put(Integer.valueOf(liToken.getLevel()),
                        Character.valueOf(liToken.getType()));
            } else if (liToken.getLevel() < curLevel) {
                for (int hiLevel = curLevel;
                        hiLevel > liToken.getLevel(); hiLevel--)
                    sb.append(spaces(hiLevel-1) + "</"
                            + ((levelTypeMap.remove(Integer.valueOf(hiLevel))
                            == '#') ? "ol" : "ul") + ">\n");
                if (liToken.getType() !=
                        levelTypeMap.get(liToken.getLevel()).charValue())
                    throw new IllegalStateException(
                            "Illegal type transition.  @line:col "
                            + (liToken.getLine()+1)
                            + ':' + (1+liToken.getColumn()));
            } else if (liToken.getLevel() == curLevel) {
                // All we do in this case is to validate the type.
                if (liToken.getType() != levelTypeMap.get(curLevel).charValue())
                    throw new IllegalStateException(
                            "Illegal type transition.  @line:col "
                            + (liToken.getLine()+1)
                            + ':' + (1+liToken.getColumn()));
            } else {
                throw new IllegalStateException(
                        "Illegal transition from list level "
                        + curLevel + " to " + liToken.getLevel()
                        + ".  @line:col " + (1+liToken.getLine())
                        + ':' + (1+liToken.getColumn()));
            }
            sb.append(spaces(liToken.getLevel()) + "<li>"
                    + liToken.getContent() + "</li>\n");
            curLevel = liToken.getLevel();
        }
        for (int hiLevel = curLevel; hiLevel > 0; hiLevel--)
            sb.append(spaces(hiLevel-1) + "</"
                    + ((levelTypeMap.remove(Integer.valueOf(hiLevel))
                    == '#') ? "ol" : "ul") + ">\n");
        return new WashedToken(sb.toString());
    }

    /**
     * TODO:  I just wrote this to get it working now.
     * Can very likely be done much more efficiently and/or elegantly.
     */
    public static String spaces(int num) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < num; i++) sb.append(INDENT_STRING);
        return sb.toString();
    }

    Deque<FontMode> fontModeStack = new ArrayDeque<FontMode>(2);

    private static final String INDENT_STRING = "  ";
:};

%terminals BLOCK_PRE, INLINE_PRE, TEXT, HARDSPACE, END_PARA, HARDLINE, HOR;
%terminals URL, IMAGE, LI, END_LI, FINAL_LI;
%terminals HEADING, EM_TOGGLE, STRONG_TOGGLE;

%typeof BLOCK_PRE, INLINE_PRE, TEXT, URL, IMAGE, HEADING = "String";
%typeof listnest = "WashedToken";

%goal blocks;

/* The grammar */
blocks = block.b+ {:
            return new WashedToken(joinWashedTokens(_list_b).toString());
        :}
        |;  // This last allows for empty document

block = isoblock.f+ {:
            return new WashedToken(joinWashedTokens(_list_f).toString());
        :}
        | inline.f+ END_PARA {:
            StringBuilder b = joinWashedTokens(_list_f);
            int lastI = b.length() - 1;
            if (b.charAt(lastI) == '\n') b.deleteCharAt(lastI);
            FontMode fm;
            while (fontModeStack.peekFirst() != null)
                b.append("</" + fontModeStack.removeFirst() + '>');
            return blockToken("<p>" + b + "</p>\n");
        :}
        | listnest.l {: return blockToken(l.toString()); :}
        ;

listnest = lastli.llitem {:
                // A single <li> list.
                // Not useful in final docs, but definitely useful for drafts.
                return newListNest(Collections.singletonList((LiToken) llitem));
            :}
         | li.litem+ lastli.llitem {:
                List<LiToken> liTokens = (List<LiToken>) _list_litem;
                liTokens.add((LiToken) llitem);
                return newListNest(liTokens);
            :};
li       = liel.li inline.l+ END_LI {:
                ((LiToken) li).setContent(joinWashedTokens(_list_l).toString());
                return li;
            :};
lastli   = liel.li inline.l+ FINAL_LI {:
                ((LiToken) li).setContent(joinWashedTokens(_list_l).toString());
                return li;
            :};
liel     = LI.listart {: return new LiToken((Token) listart); :};

inline = INLINE_PRE.text {:
            return new WashedToken("<span class=\"jcreole_pref\">"
                    + clean(text) + "</span>");
        :}
        | TEXT.f+ {: return mkWashedToken((List<String>) _list_f); :}
        | HARDSPACE {: return new WashedToken("&nbsp;"); :}
        // For hardline we do not write a \n.  If user wants a \n in addition
        // to the <br>, they should write "<br>\n".
        | HARDLINE {: return new WashedToken("<br>"); :}
        | EM_TOGGLE.t {:
            Token token = (Token) t;
            if (FontMode.EMPHASIZED.equals(fontModeStack.peekFirst())) {
                fontModeStack.pop();
                return new WashedToken("</em>");
            }
            if (fontModeStack.contains(FontMode.EMPHASIZED))
                throw new IllegalStateException(
                        "Font presentations modes are tangled.  "
                        + (token.getLine()+1)
                        + ':' + (token.getColumn()+1));
            fontModeStack.push(FontMode.EMPHASIZED);
            return new WashedToken("<em>");
        :}
        | STRONG_TOGGLE.t {:
            Token token = (Token) t;
            if (FontMode.STRONG.equals(fontModeStack.peekFirst())) {
                fontModeStack.pop();
                return new WashedToken("</strong>");
            }
            if (fontModeStack.contains(FontMode.STRONG))
                throw new IllegalStateException(
                        "Font presentations modes are tangled.  "
                        + (token.getLine()+1)
                        + ':' + (token.getColumn()+1));
            fontModeStack.push(FontMode.STRONG);
            return new WashedToken("<strong>");
        :}
        | URL.text {:
            Token token = (Token) _symbol_text;
            int delimPos = token.getIntParam();
            String inLbl = (delimPos > -1)
                         ? text.substring(delimPos + 1) : null;
            String urlText = (delimPos > -1)
                           ? text.substring(0, delimPos) : text;
            String url = null;
            Matcher matcher = (text.startsWith("http:")
                    || text.startsWith("https:")
                    || text.startsWith("ftp:")) ? null
                    : IntraWikiPattern.matcher(urlText);
            if (matcher != null && matcher.matches()) {
                if (intraWikiMapper == null) {
                    throw new IllegalStateException(String.format(
                    "%s  @line:col %d:%d",
                        "Intra-wiki links not supported.",
                        token.getLine() + 1, token.getColumn() + 1));
                }
                url = intraWikiMapper.toPath(
                        matcher.group(1), matcher.group(2));
            } else {
                url = clean(absoluteUrl(urlText));
            }
            String label = null;
            if (inLbl == null) {
                label = clean(text);
            } else {
                Matcher m = LabelPattern.matcher(inLbl);
                label = m.matches()
                    ? ("<img src=\"" + clean(absoluteUrl(m.group(1))) + "\">")
                    : clean(inLbl);
            }
            return new WashedToken("<a href=\"" + url + "\">" + label + "</a>");
        :}
        | IMAGE.text {:
            Token token = (Token) _symbol_text;
            int delimPos = token.getIntParam();
            String url = clean(absoluteUrl(
                    (delimPos > -1) ? text.substring(0, delimPos) : text));
            String alt = (delimPos > -1)
                    ? clean(text.substring(delimPos + 1)) : null;
            return new WashedToken("<img src=\"" + url
                + ((alt == null) ? "" : ("\" alt=\"" + alt)) + "\">");
        :}
        ;

// These may not contain any inlines
isoblock = HOR {: return blockToken("<hr>\n"); :}
        | HEADING.text {:
            int hLevel = ((Token) (_symbol_text)).getIntParam();
            return blockToken("<h" + hLevel + '>'
                    + clean(text) + "</h" + hLevel + ">\n");
        :}
        | BLOCK_PRE.text {: return blockToken("<pre>\n"
                + clean(text.replace("\n }}}", "\n}}}")) + "\n</pre>\n");
                // The replace here is for allowing ^}}} inside of pref block.
                // Spec says to do this for all " }}}", but that is
                // unnecessarily liberal since no escaping is needed except
                // for "^ }}}".
        :}
        ;
